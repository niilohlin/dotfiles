#!/bin/bash

set -euo pipefail

EDITOR="${EDITOR:-vi}"
TMP_FILE=$(mktemp).interactive_stage
REPO_ROOT=$(git rev-parse --show-toplevel)

cleanup() {
    rm -f "$TMP_FILE"
}
trap cleanup EXIT

# Generate relative paths from repo root
cd "$REPO_ROOT"

# Build editable instruction file
while IFS= read -r line; do
    status="${line:0:2}"
    path="${line:3}"

    case "$status" in
        "M ") echo "add $status $path" ;;
        " D") echo "rm  $status $path" ;;
        "A ") echo "add $status $path" ;;
        "??") echo "add $status $path" ;;
        "MM") echo "add $status $path" ;;
        "AM") echo "add $status $path" ;;
        " M") echo "add $status $path" ;;
        "D ") echo "#   $status $path" ;;
        *)    echo "unknown $status $path";;
    esac
done < <(git status --porcelain) > "$TMP_FILE"

# Append instructions
cat >> "$TMP_FILE" <<EOF

# Add/Restore files
#
# Commands:
# a, add <path> = add file to staging area
# r, restore <path> = restore path to original state, removes untracked files
# e, edit <path> = edit patch using git add -e
# rm, remove <path> = add a deletion to the staging area
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here that file won't be touched
#
# If you remove everything, you will exit safely
EOF

"$EDITOR" "$TMP_FILE"

echo "Processing commands..."

cd "$REPO_ROOT"

while IFS= read -r line; do
    [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue

    cmd=$(awk '{print $1}' <<< "$line")
    path=$(awk '{ $1=""; $2=""; sub(/^  */, ""); print }' <<< "$line")

    case "$cmd" in
        a|add)
            git add "$path"
            ;;
        r|restore)
            git restore "$path" || rm -rf "$path"
            ;;
        e|edit)
            git add -e "$path"
            ;;
        rm|remove)
            git rm "$path"
            ;;
        *)
            echo "Unknown command in line: $line"
            ;;
    esac
done < "$TMP_FILE"

echo "Done."
